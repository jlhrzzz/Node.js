// 前端是无法直接读取文件 操作文件 (node是使用在服务端的)
// 对文件和前端传递的数据进行处理
// 进制数据 所有内容都是以二进制来存储的

// 最终数据都是以二进制来存储的 所以会出现不精确的情况

// 二进制 十进制的区别 十进制中最大的是9 二进制中最大的是1
// 我们以字节为单位来存储数据 

// 其他进制中如何转换成十进制 当前位的值 * 进制^当前所在位 ， 把每一位进行相加
let sum = 0
for (let i = 0; i < 8; i++) {
  sum += Math.pow(2, i)
}
// 每个字节最大时255，十六进制，八进制
console.log(sum);

// 将一个十进制 转换成二进制 ? 取余数倒着读 就可以获取对应的进制

console.log(parseInt('101', 2)); // 把任意进制转换成十进制
// 0b 二进制 0x 十六进制
console.log((0x64.toString(2))); // 将任何进制转换成任意进制 (字符串)

// 小数也要转换成二进制

// 十进制的 0.5 是二进制中的多少?

// 十进制的 0，5 就是 二进制的0.1   乘二取整法可以将一个小数 转换成二进制数

// 0.1 * 2 = 0.2 0
// 0.2 * 2 = 0.4 0
// 0.4 * 2 = 0.8 0
// 0.8 * 2 = 1.6 1
// 0.6 * 2 = 1.2 1

console.log(0.1 + 0.2); // 进制转化的问题 ? 0.2 + 0.2 那如果出现了精度问题你要如何解决？
// js是没有 把小数转换成二进制的方法

// 在服务端，我们需要一个东西可以来标识内存，因为字符串无法标识图片
// node中用Buffer来标识内存的数据 他把内容转换成了十六进制来显示

// buffer每个字节的取值范围就是 0 - 0xff

// node中buffer可以和字符串任意的转换 (可能会出现乱码)

// 编码规范 ASCII => GB18030/GBK => unicode => UTF8 编码的发展史

// Buffer代表的是内存，内存是一段 "固定空间"，产生的内存是国定大小，不能随意添加
// 扩容的概念，需要动态创建一个新的内容，把内容迁移过去
const buffer = Buffer.alloc()